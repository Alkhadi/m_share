import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/rendering.dart';
import 'package:flutter/material.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import '../models/profile.dart';

/// Utility class to capture a widget to PNG and build a shareable PDF
/// with an "Active links" overlay.
class ShareBundleService {
  const ShareBundleService._();

  /// Capture a widget identified by [captureKey] to PNG bytes.  Uses a
  /// safe pixelRatio for crisp PDFs while avoiding out‑of‑memory errors on
  /// foldables.
  static Future<Uint8List> captureToPng(GlobalKey captureKey) async {
    final boundary = captureKey.currentContext?.findRenderObject()
        as RenderRepaintBoundary?;
    if (boundary == null) {
      throw StateError('captureKey boundary not found');
    }
    final pixelRatio = ui.window.devicePixelRatio.clamp(1.5, 3.0);
    final ui.Image image = await boundary
        .toImage(pixelRatio: pixelRatio.toDouble());
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    if (byteData == null) throw StateError('Failed to encode PNG bytes');
    return byteData.buffer.asUint8List();
  }

  /// Normalize a sort code by removing non-digits.
  static String _digitsOnly(String input) =>
      input.replaceAll(RegExp(r'[^0-9+]'), '');

  /// Build a map of active links from profile content.
  static Map<String, String> buildLinks(Profile profile) {
    final Map<String, String> m = {};
    if ((profile.phone ?? '').isNotEmpty) {
      final tel = _digitsOnly(profile.phone!.trim());
      m['Phone'] = 'tel:+$tel'.replaceAll('++', '+');
    }
    if ((profile.email ?? '').isNotEmpty) {
      m['Email'] = 'mailto:${profile.email!.trim()}';
    }
    if ((profile.address ?? '').isNotEmpty) {
      final q = Uri.encodeComponent(profile.address!.trim());
      m['Address'] = 'https://maps.google.com/?q=$q';
    }
    void addWeb(String label, String? raw) {
      if (raw == null || raw.trim().isEmpty) return;
      final v = raw.trim();
      final url = v.startsWith('http') ? v : 'https://$v';
      m[label] = url;
    }
    addWeb('Website', profile.website);
    addWeb('Twitter', profile.twitter);
    addWeb('Facebook', profile.facebook);
    addWeb('Instagram', profile.instagram);
    addWeb('LinkedIn', profile.linkedin);
    addWeb('YouTube', profile.youtube);
    addWeb('TikTok', profile.tiktok);
    addWeb('Snapchat', profile.snapchat);
    addWeb('Pinterest', profile.pinterest);
    addWeb('WhatsApp', profile.whatsapp);
    if ((profile.wellbeingUrl ?? '').isNotEmpty) {
      addWeb('Wellbeing', profile.wellbeingUrl);
    }
    return m;
  }

  /// Build a full‑bleed A4 PDF using the screenshot as background, plus a
  /// visible "Active links" panel with clickable links.
  static Future<Uint8List> buildPdfFromScreenshot({
    required Profile profile,
    required Uint8List screenshotPng,
    Map<String, String>? links,
  }) async {
    final doc = pw.Document();
    final img = pw.MemoryImage(screenshotPng);

    final resolvedLinks = links ?? buildLinks(profile);

    doc.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        margin: pw.EdgeInsets.zero,
        build: (_) => pw.Stack(
          children: [
            pw.Positioned.fill(child: pw.Image(img, fit: pw.BoxFit.cover)),
            if (resolvedLinks.isNotEmpty)
              pw.Align(
                alignment: pw.Alignment.bottomCenter,
                child: pw.Container(
                  padding: const pw.EdgeInsets.all(16),
                  margin: const pw.EdgeInsets.all(16),
                  decoration: pw.BoxDecoration(
                    color: PdfColor(1, 1, 1, 0.86),
                    borderRadius: pw.BorderRadius.circular(8),
                  ),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                        'Active links',
                        style: pw.TextStyle(
                          fontSize: 12,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                      pw.SizedBox(height: 6),
                      ...resolvedLinks.entries.map(
                        (e) => pw.UrlLink(
                          destination: e.value,
                          child: pw.Padding(
                            padding: const pw.EdgeInsets.symmetric(vertical: 2),
                            child: pw.Text(
                              '${e.key}: ${e.value}',
                              style: const pw.TextStyle(fontSize: 10),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
    return doc.save();
  }
}